#include <iostream>
#include <map>
#include <queue>
#include <stack>
#include <set>
#include <string>
#include <vector>
#include "main.h"

int main() {
  // Парсим выражение в НКА
  Parser parser;
  parser.read();
  parser.parse();
  // Удаляем пустые рёбра
  parser.normalize();
  // Идея решения: если слово заканчиватеся на максимум k символов x, то существует вершина,
  // из которой существует путь только по x рёбрам в какую-то конечную, притом x рёбер
  // ровно k. Полученный НКА построен так, что в любую вершину можно добраться из начальной и из любой
  // вершины можно добраться в какую-то конечную. Значит, можно построить новый граф, в который мы 
  // добавим только x рёбра, притом развернём их, и будем искать наибольший путь в новом графе
  // по этим рёбрам из каждой конечной вершины. Если нашли цикл, то можно получить сколь угодно длинное
  // окончание из x. Если не нашли цикл, то берём наибольшее из полученных в процессе поиска значений
  LargestEndingFinder finder;
  finder.read_letter();
  finder.read_NKA(parser.get_NKA());
  int k = finder.get_answer(parser.get_NKA());
  print_answer(k);
  return 0;
}